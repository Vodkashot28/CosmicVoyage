
If the Sun .glb is the only model loading and it appears tiny, the issue is almost always model scale/units or scene camera distance. GLB files can be exported in meters, centimeters, or arbitrary units; Three.js treats them as unitless, so you must scale or recenter them to match your scene’s unit system.

---

Fast fixes (apply in your GLTF loader callback)

1) Compute the model’s bounding box and scale it to a target diameter
This is the most robust approach: measure the model’s current size and scale it so it matches the size you expect.

`ts
import * as THREE from 'three';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader';

const loader = new GLTFLoader();
loader.load('/models/sun.glb', (gltf) => {
  const obj = gltf.scene;
  // compute bounding box
  const box = new THREE.Box3().setFromObject(obj);
  const size = new THREE.Vector3();
  box.getSize(size);
  const currentDiameter = Math.max(size.x, size.y, size.z);

  // desired diameter in scene units (choose a value that fits your scene)
  const desiredDiameter = 5; // example: 5 units for the Sun

  // avoid division by zero
  const scaleFactor = currentDiameter > 0 ? (desiredDiameter / currentDiameter) : 1;

  obj.scale.setScalar(scaleFactor);

  // center the model at origin
  const center = new THREE.Vector3();
  box.getCenter(center);
  obj.position.sub(center.multiplyScalar(scaleFactor)); // recenter after scaling

  scene.add(obj);
}, undefined, (err) => {
  console.error('GLTF load error', err);
});
`

Why this works: you measure the model’s real size and scale it to a predictable target so all objects share a consistent unit system.

---

2) Quick manual scale (if you just want a fast fix)
If you don’t need precise sizing, set a manual scale:

`ts
gltf.scene.scale.set(10, 10, 10); // try 5, 10, 50 until it looks right
gltf.scene.position.set(0, 0, 0);
scene.add(gltf.scene);
`

---

3) Ensure camera and controls match the new scale
If you scale the Sun up, you may need to move the camera back or adjust controls’ target:

`ts
camera.position.set(0, 0, desiredDiameter * 4); // back off relative to object size
controls.target.set(0, 0, 0);
controls.update();
`

---

4) If the model is empty or tiny geometry, use a fallback sphere
Sometimes exported models contain only a tiny mesh or are missing. Add a fallback so the scene remains usable:

`ts
if (gltf.scene.children.length === 0 || currentDiameter < 0.01) {
  const geo = new THREE.SphereGeometry(desiredDiameter / 2, 64, 64);
  const mat = new THREE.MeshStandardMaterial({ emissive: 0xffcc66, emissiveIntensity: 1 });
  const sunMesh = new THREE.Mesh(geo, mat);
  scene.add(sunMesh);
} else {
  scene.add(gltf.scene);
}
`

---

5) Export tip (if you can re-export the GLB)
When exporting from Blender/3ds Max/Maya:
- Apply scale transforms (in Blender: Ctrl+A → Apply Scale).  
- Export using meters or a consistent unit.  
- Make sure the object’s origin is centered at the model’s center.

---

Debugging checklist (quick)
- Log the bounding box and scale values: console.log(currentDiameter, scaleFactor, gltf.scene.scale).  
- Open the model URL directly to confirm it’s the correct file.  
- Try different desiredDiameter values to find a natural fit for your scene.  
- If only the Sun loads, confirm other model paths and filenames are correct and case-sensitive.

---

Example: integrate into your SolarSystemScene loader loop
`ts
modelManager.getAll().forEach(meta => {
  loader.load(meta.path, (gltf) => {
    const obj = gltf.scene;
    const box = new THREE.Box3().setFromObject(obj);
    const size = new THREE.Vector3(); box.getSize(size);
    const current = Math.max(size.x, size.y, size.z);
    const target = meta.targetDiameter ?? (meta.isSun ? 5 : 1); // per-object target
    const s = current > 0 ? (target / current) : 1;
    obj.scale.setScalar(s);
    const center = new THREE.Vector3(); box.getCenter(center);
    obj.position.sub(center.multiplyScalar(s));
    scene.add(obj);
  }, undefined, err => {
    console.warn('failed to load', meta.id, err);
    // fallback geometry here
  });
});
`

---

Final note
Pick a consistent scene unit (for example: 1 unit = 1,000 km or 1 unit = arbitrary visual unit) and scale every model to match that system. If you want, I can provide a small helper function that takes a target radius for each planet (e.g., Earth = 1 unit) and normalizes all models to that scale so relative sizes are correct.