Add console logs in the render path to see what Three.js/React is creating.  
2. Verify useSolarSystem store initializes and exposes expected state before render.  
3. Confirm model fetches return binary .glb and not HTML (404 or SPA fallback).  
4. Add camera fallback and auto-scale models to a visible size if bounding boxes are tiny.  
5. Add a simple fallback renderer (sphere placeholders) so UI shows something while models load.

---

Console logging snippets
Log render lifecycle and loaded objects
`ts
// in your main scene component or renderer init
console.log('[Solar] mounting scene', { time: Date.now() });

useEffect(() => {
  console.log('[Solar] useEffect start', { storeState: useSolarSystem.getState() });
  return () => console.log('[Solar] unmounting scene');
}, []);
`

Log when each model finishes loading
`ts
loader.load(url,
  gltf => {
    console.log('[GLTF] loaded', { url, sceneChildren: gltf.scene.children.length });
    // attach model...
  },
  progress => {
    console.log('[GLTF] progress', { url, loaded: progress.loaded, total: progress.total });
  },
  err => {
    console.error('[GLTF] error loading', { url, err });
  }
);
`

---

Check useSolarSystem initialization
Guard and log initial state
`ts
// wherever you initialize the store
const initial = {
  initialized: false,
  planets: [],
  cameraReady: false
};
const useSolarSystem = create(set => ({
  ...initial,
  init: () => set(state => ({ ...state, initialized: true })),
}));

// At app start
console.log('[Store] initial state', useSolarSystem.getState());
`

In components that consume the store
`ts
const solar = useSolarSystem();
console.log('[Component] solar store', { initialized: solar.initialized, planets: solar.planets.length });
if (!solar.initialized) {
  // show a loader or call solar.init()
}
`

---

Camera positioning and fallback rendering
Auto-fit camera to model bounding box
`ts
function fitCameraToObject(camera, object, offset = 1.25) {
  const box = new THREE.Box3().setFromObject(object);
  const size = box.getSize(new THREE.Vector3());
  const center = box.getCenter(new THREE.Vector3());
  const maxSize = Math.max(size.x, size.y, size.z);
  const fov = camera.fov * (Math.PI / 180);
  let distance = Math.abs(maxSize / 2 / Math.tan(fov / 2)) * offset;
  camera.position.set(center.x, center.y, center.z + distance);
  camera.lookAt(center);
  camera.updateProjectionMatrix();
  console.log('[Camera] fitted', { distance, center, maxSize });
}
`

Fallback placeholder while models load
`tsx
// render fallback sphere if model not ready
{!modelLoaded && <mesh>
  <sphereGeometry args={[1, 32, 32]} />
  <meshStandardMaterial color={'#888'} />
</mesh>}
`

---

Verify models are loading correctly
HEAD check for binary content (run in browser console)
`js
fetch('/models/mercury.glb', { method: 'HEAD' })
  .then(r => console.log('status', r.status, 'type', r.headers.get('content-type')))
  .catch(e => console.error('fetch head error', e));
`
Server-side static serving
- Ensure .glb files live in public/models/ (Vite) or a static folder served before SPA fallback.  
- If you see content-type: text/html or status: 200 returning HTML, fix static routing so binary files are served.

---

Quick tests to run locally or in CI
- Start dev server and open console logs.  
- Confirm GET /models/mercury.glb returns content-type: model/gltf-binary and status 200.  
- Confirm useSolarSystem.getState() shows initialized: true and planets array populated.  
- Load the scene and check logs for GLTF loaded entries and camera fit logs.
